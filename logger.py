"""
Agent Logger Module

Provides deterministic logging for agent spawns and results.
Updates IAC.md (Inter-Agent Communication) and CONTEXT.md automatically.

This module ensures all agent interactions are logged consistently,
without relying on agents to update documentation themselves.

All log files are created in the same directory as mcp_server.py,
keeping PowerSpawn self-contained with no external dependencies.

v0.5.14.1: Added file locking for concurrent agent safety
v0.5.25.1: Newest entries first, limit to 15 entries
v0.5.26.1: Simplified - always write to script directory
"""

import re
import uuid
import threading
from datetime import datetime
from pathlib import Path
from typing import Optional
from dataclasses import dataclass

# Global lock for file operations (thread-safe within process)
_file_lock = threading.Lock()

# Maximum number of entries to keep in IAC.md
MAX_IAC_ENTRIES = 15

# IAC.md header (constant)
IAC_HEADER = """# Inter-Agent Communication Log

> Auto-generated by PowerSpawn. Newest entries first. Limited to last 15 entries.

---

"""


def get_output_dir() -> Path:
    """Get the output directory for IAC.md and CONTEXT.md.

    Always returns the same directory as mcp_server.py (powerspawn/).
    This keeps PowerSpawn self-contained with no external dependencies.
    """
    return Path(__file__).parent


def get_agents_dir() -> Path:
    """Get the agents directory path (alias for get_output_dir for backwards compat)."""
    return get_output_dir()


def generate_spawn_id() -> str:
    """Generate a short unique ID for a spawn."""
    return uuid.uuid4().hex[:8]


def now_iso() -> str:
    """Get current timestamp in ISO format (UTC)."""
    return datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")


def now_time() -> str:
    """Get current time only (UTC)."""
    return datetime.utcnow().strftime("%H:%M:%S")


def now_date() -> str:
    """Get current date only (UTC)."""
    return datetime.utcnow().strftime("%Y-%m-%d")


def sanitize_for_table(text: str, max_len: int = 60) -> str:
    """Sanitize text for markdown table display (remove newlines, truncate)."""
    if not text:
        return ""
    # Replace newlines with spaces, collapse multiple spaces
    clean = ' '.join(text.split())
    if len(clean) > max_len:
        return clean[:max_len-3] + "..."
    return clean


@dataclass
class SpawnRecord:
    """Record of an agent spawn for logging."""
    spawn_id: str
    agent: str
    model: str
    task_summary: str
    prompt: str
    tools: list[str]
    started_at: str
    completed_at: Optional[str] = None
    duration_seconds: Optional[float] = None
    success: Optional[bool] = None
    cost_usd: Optional[float] = None
    result_summary: Optional[str] = None
    error: Optional[str] = None


class AgentLogger:
    """
    Logger for agent spawns and results.

    Manages IAC.md and CONTEXT.md updates.
    """

    def __init__(self):
        self.agents_dir = get_agents_dir()
        self.iac_path = self.agents_dir / "IAC.md"
        self.context_path = self.agents_dir / "CONTEXT.md"
        self.active_spawns: dict[str, SpawnRecord] = {}
        self.max_recent_runs = 10

    def _ensure_iac_exists(self):
        """Ensure IAC.md exists with proper header."""
        if not self.iac_path.exists():
            self.iac_path.write_text(IAC_HEADER, encoding='utf-8')

    def _read_iac(self) -> str:
        """Read IAC.md content."""
        self._ensure_iac_exists()
        return self.iac_path.read_text(encoding='utf-8')

    def _parse_iac_entries(self, content: str) -> list[str]:
        """Parse IAC.md content into individual entries.

        Each entry starts with '### ü§ñ' and includes everything until the next entry or EOF.
        """
        # Split by entry marker, keeping the marker
        parts = re.split(r'(### ü§ñ)', content)

        entries = []
        i = 1  # Skip first part (header)
        while i < len(parts):
            if parts[i] == '### ü§ñ' and i + 1 < len(parts):
                # Combine marker with content
                entry = parts[i] + parts[i + 1]
                entries.append(entry.strip())
                i += 2
            else:
                i += 1

        return entries

    def _write_iac(self, entries: list[str]):
        """Write IAC.md with header and entries."""
        content = IAC_HEADER
        for entry in entries:
            content += entry + "\n\n"
        self.iac_path.write_text(content, encoding='utf-8')

    def _prepend_iac(self, new_entry: str):
        """Prepend a new entry to IAC.md, keeping only MAX_IAC_ENTRIES (thread-safe)."""
        with _file_lock:
            self._ensure_iac_exists()
            content = self._read_iac()

            # Parse existing entries
            entries = self._parse_iac_entries(content)

            # Prepend new entry
            entries.insert(0, new_entry.strip())

            # Limit to MAX_IAC_ENTRIES
            entries = entries[:MAX_IAC_ENTRIES]

            # Write back
            self._write_iac(entries)

    def _update_iac_entry(
        self,
        spawn_id: str,
        success: bool,
        result_text: str,
        duration_seconds: float,
        cost_usd: float,
        error: Optional[str] = None,
    ):
        """Update an existing IAC entry with completion data (thread-safe)."""
        with _file_lock:
            content = self._read_iac()

            # Build status string for checkbox line
            if success:
                new_checkbox = f"- [x] ‚úÖ **Done** ({duration_seconds:.1f}s, ${cost_usd:.4f})"
            else:
                new_checkbox = f"- [x] ‚ùå **Failed**: {error or 'Unknown'} ({duration_seconds:.1f}s)"

            # Find and update the running checkbox line for this spawn
            import re
            # Match: - [ ] ‚è≥ **Running** | `#spawn_id` | rest of line
            old_pattern = rf"- \[ \] ‚è≥ \*\*Running\*\* \| `#{spawn_id}` \| ([^\n]+)"
            new_line = f"{new_checkbox} | `#{spawn_id}` | \\1"
            content = re.sub(old_pattern, new_line, content)

            # Replace result placeholder with actual result
            result_placeholder = f"<!-- RESULT_{spawn_id} -->"
            # Truncate very long results for display but keep essential info
            display_result = result_text
            if len(result_text) > 50000:
                display_result = result_text[:25000] + "\n\n... [truncated] ...\n\n" + result_text[-25000:]

            # Use 4 backticks as fence if result contains triple backticks
            fence = "````" if "```" in display_result else "```"

            result_block = f"""<details>
<summary>üì§ Output ({len(result_text)} chars)</summary>

{fence}
{display_result}
{fence}

</details>"""
            content = content.replace(result_placeholder, result_block)

            # Write back
            self.iac_path.write_text(content, encoding='utf-8')

    def log_spawn_start(
        self,
        agent: str,
        model: str,
        prompt: str,
        tools: list[str],
        task_summary: Optional[str] = None,
    ) -> str:
        """
        Log the start of an agent spawn.

        Returns the spawn_id for tracking.
        """
        spawn_id = generate_spawn_id()
        started_at = now_iso()

        # Create task summary from first line of prompt if not provided
        if not task_summary:
            first_line = prompt.split('\n')[0][:80]
            task_summary = first_line + ('...' if len(prompt.split('\n')[0]) > 80 else '')

        record = SpawnRecord(
            spawn_id=spawn_id,
            agent=agent,
            model=model,
            task_summary=task_summary,
            prompt=prompt,
            tools=tools,
            started_at=started_at,
        )
        self.active_spawns[spawn_id] = record

        # Write to IAC.md - unified entry format (will be updated on completion)
        tools_str = ', '.join(tools) if tools else 'None'

        # Escape backticks in prompt to prevent breaking markdown code fences
        # Use 4 backticks as fence if prompt contains triple backticks
        fence = "````" if "```" in prompt else "```"

        iac_entry = f"""### ü§ñ {task_summary}
- [ ] ‚è≥ **Running** | `#{spawn_id}` | {agent} ({model}) | {now_time()} | Tools: {tools_str}

<details>
<summary>üì• Input ({len(prompt)} chars)</summary>

{fence}
{prompt}
{fence}

</details>

<!-- RESULT_{spawn_id} -->

---"""
        self._prepend_iac(iac_entry)

        # Update CONTEXT.md with active spawn
        self._update_context()

        return spawn_id

    def log_spawn_complete(
        self,
        spawn_id: str,
        success: bool,
        result_text: str,
        duration_seconds: float,
        cost_usd: float = 0.0,
        error: Optional[str] = None,
    ):
        """Log the completion of an agent spawn."""
        record = self.active_spawns.get(spawn_id)
        if not record:
            # Spawn wasn't tracked, create minimal record
            record = SpawnRecord(
                spawn_id=spawn_id,
                agent="unknown",
                model="unknown",
                task_summary="Unknown task",
                prompt="",
                tools=[],
                started_at=now_iso(),
            )

        record.completed_at = now_iso()
        record.duration_seconds = duration_seconds
        record.success = success
        record.cost_usd = cost_usd
        record.error = error

        # Store full result (not truncated)
        record.result_summary = result_text

        # Update existing entry in IAC.md instead of appending
        self._update_iac_entry(spawn_id, success, result_text, duration_seconds, cost_usd, error)

        # Remove from active spawns
        if spawn_id in self.active_spawns:
            del self.active_spawns[spawn_id]

        # Update CONTEXT.md
        self._update_context(completed_record=record)

    def _update_context(self, completed_record: Optional[SpawnRecord] = None):
        """Update CONTEXT.md with current state."""
        # Recent runs are stored in-memory only (reset on server restart)
        # IAC.md is the authoritative log for history

        # Build active agents table
        active_table = "| ID | Agent | Task | Started |\n|-----|-------|------|--------|\n"
        if self.active_spawns:
            for sid, rec in self.active_spawns.items():
                task_clean = sanitize_for_table(rec.task_summary, 60)
                active_table += f"| {sid} | {rec.agent} | {task_clean} | {rec.started_at} |\n"
        else:
            active_table += "| - | - | No active agents | - |\n"

        # Write CONTEXT.md (thread-safe)
        with _file_lock:
            context_content = f"""# Agent Context

> Auto-generated by agents/logger.py. Do not edit manually.

**Last Updated:** {now_iso()} UTC

---

## Active Agents

{active_table}

---

## Notes

- This file shows currently running agents only
- See IAC.md for full interaction history
- See MCP_DESIGN.md for architecture documentation
"""
            self.context_path.write_text(context_content, encoding='utf-8')


# Global logger instance
_logger: Optional[AgentLogger] = None


def get_logger() -> AgentLogger:
    """Get or create the global logger instance."""
    global _logger
    if _logger is None:
        _logger = AgentLogger()
    return _logger


def log_spawn_start(
    agent: str,
    model: str,
    prompt: str,
    tools: list[str],
    task_summary: Optional[str] = None,
) -> str:
    """Log the start of an agent spawn. Returns spawn_id."""
    return get_logger().log_spawn_start(agent, model, prompt, tools, task_summary)


def log_spawn_complete(
    spawn_id: str,
    success: bool,
    result_text: str,
    duration_seconds: float,
    cost_usd: float = 0.0,
    error: Optional[str] = None,
):
    """Log the completion of an agent spawn."""
    get_logger().log_spawn_complete(
        spawn_id, success, result_text, duration_seconds, cost_usd, error
    )
